#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <list>
#include <queue>
#include <mutex>
#include <thread>
#include <stdint.h>

#include <nmath/vector.h>
#include <xtcore/tile.h>
#include <xtcore/argparse.h>
#include <xtcore/log.h>
#include <xtcore/plr_photonmapper/renderer.h>
#include "ext/stb_image.h"
#include "widgets.h"
#include "opengl.h"
#include "shader.h"
#include "logo.h"

#include "state.h"

gui::state_t state;

static std::queue<xtracer::render::tile_t*> tiles_done;
static std::queue<xtracer::render::tile_t*> tiles_started;
static std::mutex mut0, mut1;

static int block_begin(void *blk)
{
	mut0.lock();
	tiles_started.push((xtracer::render::tile_t *)blk);
	mut0.unlock();
    return 0;
}

static int block_done(void *blk)
{
	mut0.lock();
	tiles_done.push((xtracer::render::tile_t *)blk);
	mut0.unlock();
    return 0;
}

void display(void)
{
    mut0.lock();
	while(tiles_started.size() > 0) {
        xtracer::render::tile_t *t = tiles_started.front();
		tiles_started.pop();

		for (int y = t->y0(); y < t->y1(); ++y) {
            for (int x = t->x0(); x < t->x1(); ++x) {
                nimg::ColorRGBf col;
                t->read(x, y, col);
                float data[4] = {1,0,0,1};
                glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, 1, 1, GL_RGBA, GL_FLOAT, data);
            }
		}
	}

    while(tiles_done.size() > 0) {
        xtracer::render::tile_t *t = tiles_done.front();
		tiles_done.pop();

		for (int y = t->y0(); y < t->y1(); ++y) {
            for (int x = t->x0(); x < t->x1(); ++x) {
                nimg::ColorRGBf col;
                t->read(x, y, col);
                float data[4] = {col.r(), col.g(), col.b(), 1};
                glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, 1, 1, GL_RGBA, GL_FLOAT, data);
            }
		}
	}
    mut0.unlock();

    glClearColor(0.02,0.02,0.02,1);
    glClear(GL_COLOR_BUFFER_BIT);

    gui::draw_widgets(&state);

    glutSwapBuffers();
}

void reshape(int w, int h)
{
	state.window.width  = w;
	state.window.height = h;
    glViewport(0,0,(GLsizei)w,(GLsizei)h);
    glutPostRedisplay();
}

int main(int argc, char **argv)
{
    std::list<std::string>modifiers;
    xtracer::render::params_t params;
/*
    std::string renderer_name, outdir, scene_path, camera;
    if (setup(argc, argv
        , renderer_name
        , outdir
        , scene_path
        , modifiers
        , camera
        , params
    )) return 1;
    Scene scene;
    if (!scene.load(scene_path.c_str(), modifiers)) {
        if (scene.m_cameras.size() == 0) {
            Log::handle().post_error("no cameras found");
            return 2;
        }
        scene.camera = camera;
    } else return 1;

    state.renderer = new Renderer();

    state.ctx.scene  = &scene;
    state.ctx.params = params;
    state.ctx.init();

    state.renderer->setup(state.ctx);

    xtracer::render::Tileset::iterator it = state.ctx.tiles.begin();
    xtracer::render::Tileset::iterator et = state.ctx.tiles.end();
    for (; it != et; ++it) (*it).setup(block_begin, block_done);

*/
    int zero = 0;
    glutInit(&zero, 0);
    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH | GLUT_MULTISAMPLE);
    glutInitWindowSize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT);

    int window = glutCreateWindow(argv[0]);
    glutDisplayFunc(display);
    glutIdleFunc(display);
    glutReshapeFunc(reshape);
	glutKeyboardFunc(keydown);
	glutSpecialFunc(specialdown);
    glutMouseFunc(mouseCallback);
    glutMotionFunc(mouseDragCallback);
    glutPassiveMotionFunc(mouseMoveCallback);

	glewInit();
    glEnable(GL_MULTISAMPLE);

    gui::init(&state);


    state.textures.logo = load_logo();

    glGenTextures(1, &(state.textures.render));
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, state.textures.render);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
/*
    float *data = new float[state.ctx.params.width * state.ctx.params.height*4];
    memset(data, 0, sizeof(float) * 4 * state.ctx.params.width * state.ctx.params.height);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, state.ctx.params.width, state.ctx.params.height, 0, GL_RGBA, GL_FLOAT, data);
    delete data;
*/
    glutMainLoop();

	return 0;
}
